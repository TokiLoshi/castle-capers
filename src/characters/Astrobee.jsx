/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations, useCursor } from "@react-three/drei";
import * as THREE from "three";

const ACTION_MAP = {
	death: "CharacterArmature|Death",
	duck: "CharacterArmature|Duck",
	hitReact: "CharacterArmature|HitReact",
	idle: "CharacterArmature|Idle",
	idleGun: "CharacterArmature|Idle_Gun",
	jump: "CharacterArmature|Jump",
	jumpIdle: "CharacterArmature|Jump_Idle",
	jumpLand: "CharacterArmature|Jump_Land",
	no: "CharacterArmature|No",
	punch: "CharacterArmature|Punch",
	run: "CharacterArmature|Run",
	runGun: "CharacterArmature|Run_Gun",
	runGunShoot: "CharacterArmature|Run_Gun_Shoot",
	walk: "CharacterArmature|Walk",
	walkGun: "CharacterArmature|Walk_Gun",
	wave: "CharacterArmature|Wave",
	weapon: "CharacterArmature|Weapon",
	yes: "CharacterArmature|Yes",
};

const IDLE_ANIMATION_KEY = "idle";
const TRANSITION_DURATION = 0.5;

export function AstroBee({ currentAnimation = IDLE_ANIMATION_KEY, props }) {
	const group = useRef();
	const { nodes, materials, animations } = useGLTF(
		"models/characters/AstroBee.glb"
	);
	const { actions } = useAnimations(animations, group);
	console.log("Actions: ", actions);

	const currentActionRef = useRef(null);
	const timeoutRef = useRef(null);

	const [isClicked, setIsClicked] = useState(false);
	const [hovered, setHovered] = useState(false);
	useCursor(hovered /*'pointer', 'auto', document.body*/);

	useEffect(() => {
		if (!actions || Object.keys(actions).length === 0) return;

		if (timeoutRef.current) {
			clearTimeout(timeoutRef.current);
			timeoutRef.current = null;
		}

		const playIdleAnimation = () => {
			const idleFullName = ACTION_MAP[IDLE_ANIMATION_KEY];
			if (!idleFullName || !actions[idleFullName]) {
				console.warn(`Idle animation not found ${idleFullName}`);
				return;
			}

			const idleAction = actions[idleFullName];
			if (currentActionRef.current) {
				currentActionRef.current.fadeOut(TRANSITION_DURATION);
			}

			idleAction
				.reset()
				.setLoop(THREE.LoopRepeat, Infinity)
				.fadeIn(TRANSITION_DURATION)
				.play();
			currentActionRef.current = idleAction;
		};

		const playRequestedAnimation = (animationKey) => {
			if (
				animationKey === IDLE_ANIMATION_KEY &&
				currentActionRef.current === actions[ACTION_MAP[IDLE_ANIMATION_KEY]]
			)
				return;

			const fullAnimationName = ACTION_MAP[animationKey];
			if (!fullAnimationName) {
				console.warn(`Animation not found: ${animationKey}`);
				playIdleAnimation();
				return;
			}

			const targetAction = actions[fullAnimationName];
			if (currentActionRef.current) {
				currentActionRef.current.fadeOut(TRANSITION_DURATION);
			}

			if (animationKey === IDLE_ANIMATION_KEY) {
				targetAction
					.reset()
					.setLoop(THREE.LoopRepeat, Infinity)
					.fadeIn(TRANSITION_DURATION)
					.play();
			} else {
				targetAction
					.reset()
					.setLoop(THREE.LoopRepeat, 1)
					.fadeIn(TRANSITION_DURATION)
					.play();

				const duration = targetAction.getClip().duration * 1000;
				timeoutRef.current = setTimeout(() => {
					playIdleAnimation();
				}, duration + TRANSITION_DURATION * 1000);
			}
			currentActionRef.current = targetAction;
		};

		playRequestedAnimation(currentAnimation);
		return () => {
			if (timeoutRef.current) {
				clearTimeout(timeoutRef.current);
			}
		};
	}, [currentAnimation, actions]);

	const handleClick = (event) => {
		event.stopPropagation();
		setIsClicked(true);
		console.log(`Is clicked: ${isClicked}`);

		// if current animation is active fade out
		if (currentActionRef.current) {
			currentActionRef.current.fadeOut(TRANSITION_DURATION);
		}
		const actionName = ACTION_MAP["idle"];
		const actionToPlay = actions[actionName];
		actionToPlay
			.reset()
			.setLoop(THREE.LoopRepeat, 1)
			.fadeIn(TRANSITION_DURATION)
			.play();
		const duration = actionToPlay.getClip().duration * 1000;
		if (timeoutRef.current) {
			clearTimeout(timeoutRef.current);
		}

		timeoutRef.current = setTimeout(() => {
			const idleAnimation = ACTION_MAP[IDLE_ANIMATION_KEY];
			const idleAction = actions[idleAnimation];
			if (currentActionRef.current) {
				currentActionRef.current.fadeOut(TRANSITION_DURATION);
			}
			idleAction
				.reset()
				.setLoop(THREE.LoopRepeat, Infinity)
				.fadeIn(TRANSITION_DURATION);
			currentActionRef.current = idleAction;
			setIsClicked(false);
		}, duration + TRANSITION_DURATION * 1000);
	};

	return (
		<group
			ref={group}
			{...props}
			dispose={null}
			onClick={handleClick}
			onPointerOver={() => {
				setHovered(true);
			}}
			onPointerOut={() => {
				setHovered(false);
			}}>
			<group name='Root_Scene'>
				<group name='RootNode'>
					<group
						name='CharacterArmature'
						rotation={[-Math.PI / 2, 0, 0]}
						scale={100}>
						<primitive object={nodes.Root} />
					</group>
					<skinnedMesh
						name='BarbaraTheBee'
						geometry={nodes.BarbaraTheBee.geometry}
						material={materials.Atlas}
						skeleton={nodes.BarbaraTheBee.skeleton}
						rotation={[-Math.PI / 2, 0, 0]}
						scale={100}
					/>
				</group>
			</group>
		</group>
	);
}

useGLTF.preload("models/characters/AstroBee.glb");
